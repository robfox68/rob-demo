{"version":3,"file":"4884.4adbadf.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/contents.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server-extension/lib/index.js"],"sourcesContent":["import { Token } from '@lumino/coreutils';\n/**\n * The token for the settings service.\n */\nexport const IContents = new Token('@jupyterlite/contents:IContents');\n","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport localforage from 'localforage';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\n/**\n * A list of mime types of text files\n */\nconst EXTRA_TEXT_MIME_TYPES = new Set([\n    'application/javascript',\n    'application/json',\n    'application/manifest+json',\n    'application/x-python-code',\n    'application/xml',\n    'image/svg+xml',\n]);\n/**\n * A class to handle requests to /api/contents\n */\nexport class Contents {\n    /**\n     * Construct a new localForage-powered contents provider\n     */\n    constructor(options) {\n        this._serverContents = new Map();\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageName = (options || {}).contentsStorageName || DEFAULT_STORAGE_NAME;\n        this._storage = this.createDefaultStorage();\n        this._counters = this.createDefaultCounters();\n        this._checkpoints = this.createDefaultCheckpoints();\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createDefaultStorage() {\n        return localforage.createInstance({\n            name: this._storageName,\n            description: 'Offline Storage for Notebooks and Files',\n            storeName: 'files',\n            version: 1,\n        });\n    }\n    /**\n     * Initialize the default storage for counting file suffixes.\n     */\n    createDefaultCounters() {\n        return localforage.createInstance({\n            name: this._storageName,\n            description: 'Store the current file suffix counters',\n            storeName: 'counters',\n            version: 1,\n        });\n    }\n    /**\n     * Create the default checkpoint storage.\n     */\n    createDefaultCheckpoints() {\n        return localforage.createInstance({\n            name: this._storageName,\n            description: 'Offline Storage for Checkpoints',\n            storeName: 'checkpoints',\n            version: 1,\n        });\n    }\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the file is created.\n     */\n    async newUntitled(options) {\n        var _a, _b, _c;\n        const path = (_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : '';\n        const type = (_b = options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : 'notebook';\n        const created = new Date().toISOString();\n        let dirname = PathExt.dirname(path);\n        const basename = PathExt.basename(path);\n        const extname = PathExt.extname(path);\n        const item = await this.get(dirname);\n        // handle the case of \"Save As\", where the path points to the new file\n        // to create, e.g. subfolder/example-copy.ipynb\n        let name = '';\n        if (path && !extname && item) {\n            // directory\n            dirname = `${path}/`;\n            name = '';\n        }\n        else if (dirname && basename) {\n            // file in a subfolder\n            dirname = `${dirname}/`;\n            name = basename;\n        }\n        else {\n            // file at the top level\n            dirname = '';\n            name = path;\n        }\n        let file;\n        switch (type) {\n            case 'directory': {\n                const counter = await this._incrementCounter('directory');\n                name = `Untitled Folder${counter || ''}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'text',\n                    mimetype: '',\n                    content: null,\n                    size: undefined,\n                    writable: true,\n                    type: 'directory',\n                };\n                break;\n            }\n            case 'file': {\n                const ext = (_c = options === null || options === void 0 ? void 0 : options.ext) !== null && _c !== void 0 ? _c : '.txt';\n                const counter = await this._incrementCounter('file');\n                name = name || `untitled${counter || ''}${ext}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'text',\n                    // TODO: handle mimetypes\n                    mimetype: 'text/plain',\n                    content: '',\n                    size: 0,\n                    writable: true,\n                    type: 'file',\n                };\n                break;\n            }\n            default: {\n                const counter = await this._incrementCounter('notebook');\n                name = name || `Untitled${counter || ''}.ipynb`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: 'application/json',\n                    content: Private.EMPTY_NB,\n                    size: JSON.stringify(Private.EMPTY_NB).length,\n                    writable: true,\n                    type: 'notebook',\n                };\n                break;\n            }\n        }\n        const key = file.path;\n        await this._storage.setItem(key, file);\n        return file;\n    }\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param path - The original file path.\n     * @param toDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new contents model when the\n     *  file is copied.\n     *\n     * #### Notes\n     * The server will select the name of the copied file.\n     */\n    async copy(path, toDir) {\n        let name = PathExt.basename(path);\n        toDir = toDir === '' ? '' : `${toDir.slice(1)}/`;\n        // TODO: better handle naming collisions with existing files\n        while (await this.get(`${toDir}${name}`, { content: true })) {\n            const ext = PathExt.extname(name);\n            const base = name.replace(ext, '');\n            name = `${base} (copy)${ext}`;\n        }\n        const toPath = `${toDir}${name}`;\n        let item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        item = {\n            ...item,\n            name,\n            path: toPath,\n        };\n        await this._storage.setItem(toPath, item);\n        return item;\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param path: The path to the file.\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    async get(path, options) {\n        // remove leading slash\n        path = decodeURIComponent(path.replace(/^\\//, ''));\n        if (path === '') {\n            return await this._getFolder(path);\n        }\n        const item = await this._storage.getItem(path);\n        const serverItem = await this._getServerContents(path, options);\n        const model = (item || serverItem);\n        if (!model) {\n            return null;\n        }\n        if (!(options === null || options === void 0 ? void 0 : options.content)) {\n            return {\n                ...model,\n                content: null,\n                size: undefined,\n            };\n        }\n        // for directories, find all files with the path as the prefix\n        if (model.type === 'directory') {\n            const contentMap = new Map();\n            await this._storage.iterate((item, key) => {\n                const file = item;\n                // use an additional slash to not include the directory itself\n                if (key === `${path}/${file.name}`) {\n                    contentMap.set(file.name, file);\n                }\n            });\n            const serverContents = serverItem\n                ? serverItem.content\n                : Array.from((await this._getServerDirectory(path)).values());\n            for (const file of serverContents) {\n                if (!contentMap.has(file.name)) {\n                    contentMap.set(file.name, file);\n                }\n            }\n            const content = [...contentMap.values()];\n            return {\n                name: PathExt.basename(path),\n                path,\n                last_modified: model.last_modified,\n                created: model.created,\n                format: 'json',\n                mimetype: 'application/json',\n                content,\n                size: undefined,\n                writable: true,\n                type: 'directory',\n            };\n        }\n        return model;\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldLocalPath - The original file path.\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the file is renamed.\n     */\n    async rename(oldLocalPath, newLocalPath) {\n        const path = decodeURIComponent(oldLocalPath);\n        const file = await this.get(path, { content: true });\n        if (!file) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const modified = new Date().toISOString();\n        const name = PathExt.basename(newLocalPath);\n        const newFile = {\n            ...file,\n            name,\n            path: newLocalPath,\n            last_modified: modified,\n        };\n        await this._storage.setItem(newLocalPath, newFile);\n        // remove the old file\n        await this._storage.removeItem(path);\n        // remove the corresponding checkpoint\n        await this._checkpoints.removeItem(path);\n        // if a directory, recurse through all children\n        if (file.type === 'directory') {\n            let child;\n            for (child of file.content) {\n                await this.rename(URLExt.join(oldLocalPath, child.name), URLExt.join(newLocalPath, child.name));\n            }\n        }\n        return newFile;\n    }\n    /**\n     * Save a file.\n     *\n     * @param path - The desired file path.\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the file is saved.\n     */\n    async save(path, options = {}) {\n        var _a;\n        path = decodeURIComponent(path);\n        let item = (await this.get(path)) || (await this.newUntitled({ path }));\n        if (!item) {\n            return null;\n        }\n        // override with the new values\n        const modified = new Date().toISOString();\n        item = {\n            ...item,\n            ...options,\n            last_modified: modified,\n        };\n        // process the file if coming from an upload\n        const ext = PathExt.extname((_a = options.name) !== null && _a !== void 0 ? _a : '');\n        if (options.content && options.format === 'base64') {\n            // TODO: keep base64 if not a text file (image)\n            const content = atob(options.content);\n            const nb = ext === '.ipynb';\n            item = {\n                ...item,\n                content: nb ? JSON.parse(content) : content,\n                format: nb ? 'json' : 'text',\n                type: nb ? 'notebook' : 'file',\n            };\n        }\n        await this._storage.setItem(path, item);\n        return item;\n    }\n    /**\n     * Delete a file.\n     *\n     * @param path - The path to the file.\n     */\n    async delete(path) {\n        path = decodeURIComponent(path);\n        const toDelete = [];\n        // handle deleting directories recursively\n        await this._storage.iterate((item, key) => {\n            if (key === path || key.startsWith(`${path}/`)) {\n                toDelete.push(key);\n            }\n        });\n        await Promise.all(toDelete.map(async (p) => {\n            return Promise.all([\n                this._storage.removeItem(p),\n                this._checkpoints.removeItem(p),\n            ]);\n        }));\n    }\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    async createCheckpoint(path) {\n        var _a;\n        path = decodeURIComponent(path);\n        const item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const copies = ((_a = (await this._checkpoints.getItem(path))) !== null && _a !== void 0 ? _a : []).filter((item) => !!item);\n        copies.push(item);\n        // keep only a certain amount of checkpoints per file\n        if (copies.length > N_CHECKPOINTS) {\n            copies.splice(0, copies.length - N_CHECKPOINTS);\n        }\n        await this._checkpoints.setItem(path, copies);\n        const id = `${copies.length - 1}`;\n        return {\n            id,\n            last_modified: item.last_modified,\n        };\n    }\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    async listCheckpoints(path) {\n        const copies = ((await this._checkpoints.getItem(path)) ||\n            []);\n        return copies\n            .filter((item) => !!item)\n            .map((file, id) => {\n            return {\n                id: id.toString(),\n                last_modified: file.last_modified,\n            };\n        });\n    }\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    async restoreCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await this._checkpoints.getItem(path)) ||\n            []);\n        const id = parseInt(checkpointID);\n        const item = copies[id];\n        await this._storage.setItem(path, item);\n    }\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    async deleteCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await this._checkpoints.getItem(path)) ||\n            []);\n        const id = parseInt(checkpointID);\n        copies.splice(id, 1);\n        await this._checkpoints.setItem(path, copies);\n    }\n    /**\n     * retrieve the contents for this path from the union of local storage and\n     * `api/contents/{path}/all.json`.\n     *\n     * @param path - The contents path to retrieve\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getFolder(path) {\n        const content = new Map();\n        await this._storage.iterate((item, key) => {\n            if (key.includes('/')) {\n                return;\n            }\n            const file = item;\n            content.set(file.path, file);\n        });\n        // layer in contents that don't have local overwrites\n        for (const file of (await this._getServerDirectory(path)).values()) {\n            if (!content.has(file.path)) {\n                content.set(file.path, file);\n            }\n        }\n        if (path && content.size === 0) {\n            return null;\n        }\n        return {\n            name: '',\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'json',\n            mimetype: 'application/json',\n            content: Array.from(content.values()),\n            size: undefined,\n            writable: true,\n            type: 'directory',\n        };\n    }\n    /**\n     * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n     * deriving the model (including content) off the file in `/files/`. Otherwise\n     * return `null`.\n     */\n    async _getServerContents(path, options) {\n        const name = PathExt.basename(path);\n        const parentContents = await this._getServerDirectory(URLExt.join(path, '..'));\n        let model = parentContents.get(name);\n        if (!model) {\n            return null;\n        }\n        model = model || {\n            name,\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'text',\n            mimetype: 'text/plain',\n            type: 'file',\n            writable: true,\n            content: null,\n        };\n        if (options === null || options === void 0 ? void 0 : options.content) {\n            if (model.type === 'directory') {\n                const serverContents = await this._getServerDirectory(path);\n                model = { ...model, content: Array.from(serverContents.values()) };\n            }\n            else {\n                const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n                const response = await fetch(fileUrl);\n                if (!response.ok) {\n                    return null;\n                }\n                const mimetype = model.mimetype || response.headers.get('Content-Type');\n                if (model.type === 'notebook' ||\n                    (mimetype === null || mimetype === void 0 ? void 0 : mimetype.indexOf('json')) !== -1 ||\n                    path.match(/\\.(ipynb|[^/]*json[^/]*)$/)) {\n                    model = {\n                        ...model,\n                        content: await response.json(),\n                        format: 'json',\n                        mimetype: model.mimetype || 'application/json',\n                    };\n                }\n                else if (mimetype.indexOf('text') !== -1 ||\n                    EXTRA_TEXT_MIME_TYPES.has(mimetype)) {\n                    model = {\n                        ...model,\n                        content: await response.text(),\n                        format: 'text',\n                        mimetype: mimetype || 'text/plain',\n                    };\n                }\n                else {\n                    model = {\n                        ...model,\n                        content: btoa(String.fromCharCode(...new Uint8Array(await response.arrayBuffer()))),\n                        format: 'base64',\n                        mimetype: mimetype || 'octet/stream',\n                    };\n                }\n            }\n        }\n        return model;\n    }\n    /**\n     * retrieve the contents for this path from `__index__.json` in the appropriate\n     * folder.\n     *\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getServerDirectory(path) {\n        const content = this._serverContents.get(path) || new Map();\n        if (!this._serverContents.has(path)) {\n            const apiURL = URLExt.join(PageConfig.getBaseUrl(), 'api/contents', path, 'all.json');\n            try {\n                const response = await fetch(apiURL);\n                const json = JSON.parse(await response.text());\n                for (const file of json['content']) {\n                    content.set(file.name, file);\n                }\n            }\n            catch (err) {\n                console.warn(`don't worry, about ${err}... nothing's broken. if there had been a\n          file at ${apiURL}, you might see some more files.`);\n            }\n            this._serverContents.set(path, content);\n        }\n        return content;\n    }\n    /**\n     * Increment the counter for a given file type.\n     * Used to avoid collisions when creating new untitled files.\n     *\n     * @param type The file type to increment the counter for.\n     */\n    async _incrementCounter(type) {\n        var _a;\n        const current = (_a = (await this._counters.getItem(type))) !== null && _a !== void 0 ? _a : -1;\n        const counter = current + 1;\n        await this._counters.setItem(type, counter);\n        return counter;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The content for an empty notebook.\n     */\n    Private.EMPTY_NB = {\n        metadata: {\n            orig_nbformat: 4,\n        },\n        nbformat_minor: 4,\n        nbformat: 4,\n        cells: [],\n    };\n})(Private || (Private = {}));\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { Contents, IContents } from '@jupyterlite/contents';\nimport { IKernels, Kernels, IKernelSpecs, KernelSpecs } from '@jupyterlite/kernel';\nimport { JupyterServer, LiteServiceManager, } from '@jupyterlite/server';\nimport { ISessions, Sessions } from '@jupyterlite/session';\nimport { ISettings, Settings } from '@jupyterlite/settings';\nimport { ITranslation, Translation } from '@jupyterlite/translation';\n/**\n * The contents service plugin.\n */\nconst contents = {\n    id: '@jupyterlite/server-extension:contents',\n    autoStart: true,\n    provides: IContents,\n    activate: (app) => {\n        const contentsStorageName = PageConfig.getOption('contentsStorageName');\n        return new Contents({ contentsStorageName });\n    },\n};\n/**\n * The kernels service plugin.\n */\nconst kernels = {\n    id: '@jupyterlite/server-extension:kernels',\n    autoStart: true,\n    provides: IKernels,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        return new Kernels({ kernelspecs });\n    },\n};\n/**\n * The kernel spec service plugin.\n */\nconst kernelSpec = {\n    id: '@jupyterlite/server-extension:kernelspec',\n    autoStart: true,\n    provides: IKernelSpecs,\n    activate: (app) => {\n        return new KernelSpecs({});\n    },\n};\n/**\n * The sessions service plugin.\n */\nconst sessions = {\n    id: '@jupyterlite/server-extension:sessions',\n    autoStart: true,\n    provides: ISessions,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        return new Sessions({ kernels });\n    },\n};\n/**\n * The server plugin.\n */\nconst server = {\n    id: '@jupyterlite/server-extension:server',\n    autoStart: true,\n    requires: [IContents, IKernels, IKernelSpecs, ISessions, ISettings, ITranslation],\n    activate: (app, contents, kernels, kernelspecs, sessions, settings, translation) => {\n        const jupyterServer = new JupyterServer({\n            contents,\n            kernels,\n            kernelspecs,\n            sessions,\n            settings,\n            translation,\n        });\n        const serviceManager = new LiteServiceManager({ server: jupyterServer });\n        app.registerServiceManager(serviceManager);\n    },\n};\n/**\n * The settings service plugin.\n */\nconst settings = {\n    id: '@jupyterlite/server-extension:settings',\n    autoStart: true,\n    provides: ISettings,\n    activate: (app) => {\n        const settingsStorageName = PageConfig.getOption('settingsStorageName');\n        return new Settings({ settingsStorageName });\n    },\n};\n/**\n * The translation service plugin.\n */\nconst translation = {\n    id: '@jupyterlite/server-extension:translation',\n    autoStart: true,\n    provides: ITranslation,\n    activate: (app) => {\n        return new Translation();\n    },\n};\nconst plugins = [\n    contents,\n    kernels,\n    kernelSpec,\n    server,\n    sessions,\n    settings,\n    translation,\n];\nexport default plugins;\n"],"names":["IContents","Token","DEFAULT_STORAGE_NAME","EXTRA_TEXT_MIME_TYPES","Set","Contents","constructor","options","this","_serverContents","Map","_storageName","contentsStorageName","_storage","createDefaultStorage","_counters","createDefaultCounters","_checkpoints","createDefaultCheckpoints","name","description","storeName","version","async","_a","_b","_c","path","type","created","Date","toISOString","dirname","PathExt","basename","extname","item","get","file","_incrementCounter","last_modified","format","mimetype","content","size","undefined","writable","ext","counter","Private","EMPTY_NB","JSON","stringify","length","key","setItem","toDir","slice","base","replace","toPath","Error","decodeURIComponent","_getFolder","getItem","serverItem","_getServerContents","model","contentMap","iterate","set","serverContents","Array","from","_getServerDirectory","values","has","oldLocalPath","newLocalPath","modified","newFile","removeItem","child","rename","URLExt","newUntitled","atob","nb","parse","toDelete","startsWith","push","Promise","all","map","p","copies","filter","splice","id","toString","checkpointID","parseInt","includes","fileUrl","PageConfig","response","fetch","ok","headers","indexOf","match","json","text","btoa","String","fromCharCode","Uint8Array","arrayBuffer","apiURL","err","console","warn","metadata","orig_nbformat","nbformat_minor","nbformat","cells","contents","autoStart","provides","activate","app","kernels","IKernels","requires","IKernelSpecs","kernelspecs","Kernels","kernelSpec","KernelSpecs","sessions","ISessions","Sessions","server","ISettings","ITranslation","settings","translation","jupyterServer","JupyterServer","serviceManager","LiteServiceManager","registerServiceManager","settingsStorageName","Settings","Translation"],"sourceRoot":""}